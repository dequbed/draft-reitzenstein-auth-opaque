{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-08-20T00:31:53.991131+00:00",
  "repo": "dequbed/draft-reitzenstein-auth-opaque",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOH68eks5TPEb1",
      "title": "Usage of Channel Binding",
      "url": "https://github.com/dequbed/draft-reitzenstein-auth-opaque/issues/1",
      "state": "CLOSED",
      "author": "dequbed",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Moving this issue to not derail the original one:\r\n\r\n> Channel binding is about binding an authentication to an underlying encrypted channel like TLS and thus making sure that both sides see the same channel. That's very much not something that OPAQUE gives you implicitly.\r\n\r\nok, it might seem a dumb question, but it's genuine. what does it matter if a channel is encrypted or not, if the goal is to make sure that both sides see the same channel? and if the two parties can authenticate each other (which they do) then presuming that the ephemeral keys are indeed only used once, the authentication is bound to that tcp connection - limiting here to tcp like transports makes sense i hope, with udp this might not work. so i think opaque does indeed bind to a channel implicitly, and i think the fact of it being encrypted does not matter, as long as the channel is tcp-like connection-based.\r\n\r\n_Originally posted by @stef in https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/375#issuecomment-1267128310_\r\n",
      "createdAt": "2022-10-04T15:19:41Z",
      "updatedAt": "2022-10-06T18:02:19Z",
      "closedAt": "2022-10-06T18:02:19Z",
      "comments": [
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "> ok, it might seem a dumb question, but it's genuine. what does it matter if a channel is encrypted or not, if the goal is to make sure that both sides see the same channel? and if the two parties can authenticate each other (which they do) then presuming that the ephemeral keys are indeed only used once, the authentication is bound to that tcp connection - limiting here to tcp like transports makes sense i hope, with udp this might not work. so i think opaque does indeed bind to a channel implicitly, and i think the fact of it being encrypted does not matter, as long as the channel is tcp-like connection-based.\r\n\r\nRight, I think we need to fix terminology here:\r\nThe encrypted \"channel\" that is referred to here is the outer secure transport, not anything inside the authentication itself. So, for example if we have an TLS-encrypted XMPP session this TLS layer is the \"channel\" that is being bound to. \r\n\r\nWhat channel binding aims to do is assure to both parties that this encrypted channel is not being intercepted. This is done by taking some data that uniquely identifies the encrypted channel, such as a transcript hash, TLS exporter data or a hash of a certificate or public key used, and including that data into the cryptographic authentication.\r\n\r\nThis way the authentication will only succeed if both sides can agree on this data. This way users can be sure their encrypted channel is not being MitM-ed, preventing certain attacks where an attacker waits for an user to authenticate and then uses the elevated permissions of the session context to do nefarious things.",
          "createdAt": "2022-10-04T15:19:53Z",
          "updatedAt": "2022-10-04T15:19:53Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "Relevant documents are:\r\n\r\n[RFC 5056 for the general principle of channel binding](https://www.rfc-editor.org/rfc/rfc5056)\r\n\r\n[RFC 9266 for channel binding using TLS exporter](https://www.rfc-editor.org/rfc/rfc9266)\r\n\r\n[RFC 5929 for channel binding using the public key/certificate used](https://www.rfc-editor.org/rfc/rfc5929)\r\n\r\n[RFC 5802, Section 6 for an example how channel binding is used in SCRAM](https://www.rfc-editor.org/rfc/rfc5802#section-6)",
          "createdAt": "2022-10-04T15:24:42Z",
          "updatedAt": "2022-10-04T15:24:42Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> Right, I think we need to fix terminology here: The encrypted \"channel\" that is referred to here is the outer secure transport, not anything inside the authentication itself. So, for example if we have an TLS-encrypted XMPP session this TLS layer is the \"channel\" that is being bound to.\r\n\r\nthis is clear.\r\n\r\n> What channel binding aims to do is assure to both parties that this encrypted channel is not being intercepted. \r\n\r\nbut this is not what you wrote in the parent post, where you wrote: \r\n\r\n> Channel binding is about binding an authentication to an underlying encrypted channel like TLS and thus making sure that both sides see the same channel.\r\n\r\nand with this interpretation my argument holds the authentication itself is bound to the channel.\r\n\r\nyou continue:\r\n\r\n> This is done by taking some data that uniquely identifies the encrypted channel, such as a transcript hash, TLS exporter data or a hash of a certificate or public key used, and including that data into the cryptographic authentication.\r\n\r\nbut the encrypted(or not) channel is already identified by the ephemeral keys at the end of both peers. as long as those ephemeral keys are not reused in the same pair, this should be already binding the session to the tcp channel.\r\n\r\n> This way the authentication will only succeed if both sides can agree on this data. This way users can be sure their encrypted channel is not being MitM-ed, preventing certain attacks where an attacker waits for an user to authenticate and then uses the elevated permissions of the session context to do nefarious things.\r\n\r\nso then it is not about binding the authentication to the channel, but to actually make sure that the messages after the authentication are from the authenticated peers, and no one else.\r\n\r\nbut that means that the channel doesn't have to be encrypted, it's enough if the channel is authenticated, so that a mitm cannot change or inject extra messages. and this also means that channel binding only makes sense if there is some kind of security layer (be it auth, or non-malleable confidentiality) after the authentication is successful. \r\n\r\non the other hand this makes SASL OPAQUE with channel binding kinda impossible to use in enterprise settings with MITMboxes at the perimeter, so i guess it has to be optional.\r\n\r\nbut i guess this kinda makes a case for channel binding to a secure layer, be it tls or the SL from saSL. imo the best solution would be if this would be revived: https://datatracker.ietf.org/doc/draft-sullivan-tls-opaque/ and passed. i tried many times triggering nick and chris to pick this up, maybe you can also trigger them?\r\n\r\nthanks for clarifying.",
          "createdAt": "2022-10-04T16:08:28Z",
          "updatedAt": "2022-10-04T16:08:28Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "> > This way the authentication will only succeed if both sides can agree on this data. This way users can be sure their encrypted channel is not being MitM-ed, preventing certain attacks where an attacker waits for an user to authenticate and then uses the elevated permissions of the session context to do nefarious things.\r\n> \r\n> so then it is not about binding the authentication to the channel, but to actually make sure that the messages after the authentication are from the authenticated peers, and no one else.\r\n\r\nYes, that is the core idea. Granted, I use the words \"encrypted\" and \"secure\" interchangeable because with todays cryptography secure channels that offer integrity but don't offer confidentiality have become vanishingly rare, although they are of course separate concepts.\r\n\r\n> > What channel binding aims to do is assure to both parties that this encrypted channel is not being intercepted.\r\n> \r\n> but this is not what you wrote in the parent post, where you wrote:\r\n> \r\n> > Channel binding is about binding an authentication to an underlying encrypted channel like TLS and thus making sure that both sides see the same channel.\r\n> \r\n> and with this interpretation my argument holds the authentication itself is bound to the channel.\r\n \r\nI should have chosen my words here more carefully, I of course mean actively intercepted. But then no, those two statements imply the exact same, even more so if you read \"encrypted channel\" as \"secure channel\".\r\n\r\n\r\n> you continue:\r\n> \r\n> > This is done by taking some data that uniquely identifies the encrypted channel, such as a transcript hash, TLS exporter data or a hash of a certificate or public key used, and including that data into the cryptographic authentication.\r\n> \r\n> but the encrypted(or not) channel is already identified by the ephemeral keys at the end of both peers. as long as those ephemeral keys are not reused in the same pair, this should be already binding the session to the tcp channel.\r\n\r\nNo. Nothing necessarily identifies the ephemeral keys, not reusing them does not guard at all against an active attacker. For that you need to either pre-emptively authenticate those keys via e.g. PKI, or authenticate them later, e.g. \u2014 as channel binding does \u2014 via the user authentication.\r\n\r\n\r\n> [\u2026] but that means that the channel doesn't have to be encrypted, it's enough if the channel is authenticated, so that a mitm cannot change or inject extra messages. and this also means that channel binding only makes sense if there is some kind of security layer (be it auth, or non-malleable confidentiality) after the authentication is successful.\r\n\r\nYes, and? \r\n\r\nNotably, this does not imply that this channel can not already exist beforehand.\r\n\r\n> on the other hand this makes SASL OPAQUE with channel binding kinda impossible to use in enterprise settings with MITMboxes at the perimeter, so i guess it has to be optional.\r\n\r\nNot necessarily. \r\n\r\nBut usually channel binding is an optional feature.\r\n\r\n> but i guess this kinda makes a case for channel binding to a secure layer, be it tls or the SL from saSL. \r\n\r\nYou do not need to channel bind to a security layer established using SASL. The authenticity of it is *already* established due to the authentication it came from. Channel binding is a *better replacement* for SASL security layers.\r\n\r\n> imo the best solution would be if this would be revived: https://datatracker.ietf.org/doc/draft-sullivan-tls-opaque/ and passed. i tried many times triggering nick and chris to pick this up, maybe you can also trigger them?\r\n\r\nUsing OPAQUE to set up an authenticated TLS channel is completely orthogonal to SASL channel binding and does not remove the need for it.",
          "createdAt": "2022-10-04T16:32:16Z",
          "updatedAt": "2022-10-04T16:33:09Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> Yes, that is the core idea. Granted, I use the words \"encrypted\" and \"secure\" interchangeable because with todays cryptography secure channels that offer integrity but don't offer confidentiality have become vanishingly rare, although they are of course separate concepts.\r\n\r\nneither encrypted nor secure have a well defined meaning. it's better to spell out the security guarantees.\r\n\r\n> > > What channel binding aims to do is assure to both parties that this encrypted channel is not being intercepted.\r\n> > \r\n> > \r\n> > but this is not what you wrote in the parent post, where you wrote:\r\n> > > Channel binding is about binding an authentication to an underlying encrypted channel like TLS and thus making sure that both sides see the same channel.\r\n> > and with this interpretation my argument holds the authentication itself is bound to the channel.\r\n> \r\n> I should have chosen my words here more carefully, I of course mean actively intercepted. But then no, those two statements imply the exact same, even more so if you read \"encrypted channel\" as \"secure channel\".\r\n\r\ni dunno, does encrypted mean confidentiality + authenticity, or integrity? does secure channel mean any of these things? and my interpretation only means that the authentication is bound to the channel, meaning the authentication cannot be replayed or reused. your interpretation goes further than that. both are valid, just from different perspectives/understanding what has been said before.\r\n\r\n> > but the encrypted(or not) channel is already identified by the ephemeral keys at the end of both peers. as long as those ephemeral keys are not reused in the same pair, this should be already binding the session to the tcp channel.\r\n> \r\n> No. Nothing necessarily identifies the ephemeral keys, not reusing them does not guard at all against an active attacker. For that you need to either pre-emptively authenticate those keys via e.g. PKI, or authenticate them later, e.g. \u2014 as channel binding does \u2014 via the user authentication.\r\n\r\nof course noone ever authenticates ephemeral keys, that makes no sense. hence you have long-term keys also\r\nthese are essential in this setup, via x3dh. and those are(or should be) authenticated during registration. the reason for having ephemeral keys is to have each session being unique, and you could say bound to each other, at least for the sake of replayability and forward security. \r\n\r\n> > [\u2026] but that means that the channel doesn't have to be encrypted, it's enough if the channel is authenticated, so that a mitm cannot change or inject extra messages. and this also means that channel binding only makes sense if there is some kind of security layer (be it auth, or non-malleable confidentiality) after the authentication is successful.\r\n> \r\n> Yes, and?\r\n> Notably, this does not imply that this channel can not already exist beforehand.\r\n\r\nno but it implies that the channel up to the authentication can be an entirely different one from the one after the authentication.\r\n\r\n> > on the other hand this makes SASL OPAQUE with channel binding kinda impossible to use in enterprise settings with MITMboxes at the perimeter, so i guess it has to be optional.\r\n> \r\n> Not necessarily.\r\n> But usually channel binding is an optional feature.\r\n> \r\n> > but i guess this kinda makes a case for channel binding to a secure layer, be it tls or the SL from saSL.\r\n> \r\n> You do not need to channel bind to a security layer established using SASL. The authenticity of it is _already_ established due to the authentication it came from. Channel binding is a _better replacement_ for SASL security layers.\r\n\r\nwell i can totally imagine a completely plaintext (no CIA whatsoever) connection that authenticates parties that authenticate each other via opaque. although i'm not sure what you mean with \"the authenticity of ?it? is _already_ established due to the authentication it comes from\" i can also totally imagine a TLS connection via a MITMbox that authenticates peers using opaque. and when you write \"channel binding is a better replacement[..]\" again i'm not sure i understand you, since if you do OPAQUE and use the shared secret that falls out of it to just do a simple xchacha/poly1305 using that you also have implicit channel binding, even if there is an active party in the middle.\r\n\r\n> \r\n> > imo the best solution would be if this would be revived: https://datatracker.ietf.org/doc/draft-sullivan-tls-opaque/ and passed. i tried many times triggering nick and chris to pick this up, maybe you can also trigger them?\r\n> \r\n> Using OPAQUE to set up an authenticated TLS channel is completely orthogonal to SASL channel binding and does not remove the need for it.\r\n\r\nno, not at all. tls is just another security layer (with a whole lot of design-by-committee and politics) that is completely interchangeable with any other \"sane\" security layer. and actually TLS makes a lot of sense since it is an established proto, that is mostly tolerated everywhere (even the GFW). and opaque+tls is combining the best of both worlds. and i believe that tls-opaque is the correct way to do a sasl security layer based on opaque. (other than feeding a double ratchet, or just plain naked xchacha20/poly1305)\r\n\r\n",
          "createdAt": "2022-10-04T17:01:14Z",
          "updatedAt": "2022-10-04T17:01:14Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i think the trouble is we have very different perspectives, and understand different parts of the domain. it's very productive to trying to understand the other interpretation. thank you for this dialogue!",
          "createdAt": "2022-10-04T17:02:27Z",
          "updatedAt": "2022-10-04T17:02:27Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "> neither encrypted nor secure have a well defined meaning. it's better to spell out the security guarantees.\r\n\r\n[RFC 5056, Section 2](https://www.rfc-editor.org/rfc/rfc5056#section-2)\r\n\r\n> i dunno, does encrypted mean confidentiality + authenticity, or integrity? does secure channel mean any of these things? and my interpretation only means that the authentication is bound to the channel, meaning the authentication cannot be replayed or reused. your interpretation goes further than that. both are valid, just from different perspectives/understanding what has been said before.\r\n\r\n[RFC 5056, Section 2](https://www.rfc-editor.org/rfc/rfc5056#section-2)\r\n\r\nI use \"encrypted channel\" as a secure channel offering confidentiality and integrity.\r\n\r\n> > > but the encrypted(or not) channel is already identified by the ephemeral keys at the end of both peers. as long as those ephemeral keys are not reused in the same pair, this should be already binding the session to the tcp channel.\r\n> > \r\n> > \r\n> > No. Nothing necessarily identifies the ephemeral keys, not reusing them does not guard at all against an active attacker. For that you need to either pre-emptively authenticate those keys via e.g. PKI, or authenticate them later, e.g. \u2014 as channel binding does \u2014 via the user authentication.\r\n> \r\n> of course noone ever authenticates ephemeral keys, that makes no sense. hence you have long-term keys also these are essential in this setup, via x3dh. and those are(or should be) authenticated during registration. the reason for having ephemeral keys is to have each session being unique, and you could say bound to each other, at least for the sake of replayability and forward security.\r\n\r\nThis does not in any way authenticate long- or short term keys used by the secure channel. This is *exactly* what channel binding is about; authenticating the otherwise independently set up secure channel, usually by authenticating the keys used.\r\n\r\n> > > [\u2026] but that means that the channel doesn't have to be encrypted, it's enough if the channel is authenticated, so that a mitm cannot change or inject extra messages. and this also means that channel binding only makes sense if there is some kind of security layer (be it auth, or non-malleable confidentiality) after the authentication is successful.\r\n> > \r\n> > \r\n> > Yes, and?\r\n> > Notably, this does not imply that this channel can not already exist beforehand.\r\n> \r\n> no but it implies that the channel up to the authentication can be an entirely different one from the one after the authentication.\r\n\r\nYes, and?\r\n\r\n\r\n> > You do not need to channel bind to a security layer established using SASL. The authenticity of it is _already_ established due to the authentication it came from. Channel binding is a _better replacement_ for SASL security layers.\r\n> \r\n> well i can totally imagine a completely plaintext (no CIA whatsoever) connection that authenticates parties that authenticate each other via opaque. although i'm not sure what you mean with \"the authenticity of ?it? is _already_ established due to the authentication it comes from\" i can also totally imagine a TLS connection via a MITMbox that authenticates peers using opaque. and when you write \"channel binding is a better replacement[..]\" again i'm not sure i understand you, since if you do OPAQUE and use the shared secret that falls out of it to just do a simple xchacha/poly1305 using that you also have implicit channel binding, even if there is an active party in the middle.\r\n\r\nIf you use SASL security layers the security layer is a product of the authentication exchange. As a very rough approximation a proper SASL authentication exchange establishing a security layer should behave somewhat similar to an AKE (authenticated key exchange).\r\nSo, the \"authenticity of [the security layer] is *already* established [because it is based on a modified AKE]\"\r\n\r\nAnd thus, yes exactly. If you would use the session key from an OPAQUE authentication to establish a security layer you do not need channel binding.\r\n\r\n> > Using OPAQUE to set up an authenticated TLS channel is completely orthogonal to SASL channel binding and does not remove the need for it.\r\n> \r\n> no, not at all. tls is just another security layer (with a whole lot of design-by-committee and politics) that is completely interchangeable with any other \"sane\" security layer. and actually TLS makes a lot of sense since it is an established proto, that is mostly tolerated everywhere (even the GFW). and opaque+tls is combining the best of both worlds. and i believe that tls-opaque is the correct way to do a sasl security layer based on opaque. \r\n\r\nNo, this is entirely orthogonal. Using OPAQUE to bootstrap TLS has the specific applicability of setting up a mutually authenticated encrypted channel using TLS, much like client certificates do. And similiar to client certificates you would then use SASL `EXTERNAL` as the appropiate SASL mechanism.\r\n\r\nTo drill it down, SASL security layers are a *very specific* concept. They are very much not \"just use a secure channel like TLS\". So no, TLS-OPAQUE is not combining the best of both worlds, it is an entirely different thing.\r\n\r\nI will give you half a point though. Using the TLS state machine is probably the best way of doing a SASL security layer. But you wouldn't use TLS-OPAQUE, because that doesn't give you what you need for SASL. Instead you'd do SASL OPAQUE and then use TLS-PSK with the session key.\r\n\r\nBut at that point, **just use TLS**. The most you can save here is a single roundtrip for STARTTLS. And if you must reduce round-trips, just use TLS-OPAQUE and SASL EXTERNAL.\r\n\r\n> ([\u2026] or just plain naked xchacha20/poly1305)\r\n\r\nAnd that is a dangerous idea. A lot of the TLS state machine is required to make the usage limits of this AEAD are never hit.",
          "createdAt": "2022-10-04T17:46:09Z",
          "updatedAt": "2022-10-05T14:32:44Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "I'd like to say sorry for my rather harsh wording yesterday. I had become a bit exasperated and it was undue.",
          "createdAt": "2022-10-05T14:34:15Z",
          "updatedAt": "2022-10-05T14:34:15Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "no worries! it's not easy and it seems we have very different perspectives, so that leads to misunderstandings.",
          "createdAt": "2022-10-05T14:44:35Z",
          "updatedAt": "2022-10-05T14:44:35Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> > neither encrypted nor secure have a well defined meaning. it's better to spell out the security guarantees.\r\n> \r\n> [RFC 5056, Section 2](https://www.rfc-editor.org/rfc/rfc5056#section-2)\r\n\r\nah. ok, i guess it makes sense to limit the context and definition this rfc. thanks.\r\n\r\n> > i dunno, does encrypted mean confidentiality + authenticity, or integrity? does secure channel mean any of these things? and my interpretation only means that the authentication is bound to the channel, meaning the authentication cannot be replayed or reused. your interpretation goes further than that. both are valid, just from different perspectives/understanding what has been said before.\r\n> \r\n> [RFC 5056, Section 2](https://www.rfc-editor.org/rfc/rfc5056#section-2)\r\n> \r\n> I use \"encrypted channel\" as a secure channel offering confidentiality and integrity.\r\n\r\ni see.\r\n\r\n> > > > but the encrypted(or not) channel is already identified by the ephemeral keys at the end of both peers. as long as those ephemeral keys are not reused in the same pair, this should be already binding the session to the tcp channel.\r\n> > > \r\n> > > \r\n> > > No. Nothing necessarily identifies the ephemeral keys, not reusing them does not guard at all against an active attacker. For that you need to either pre-emptively authenticate those keys via e.g. PKI, or authenticate them later, e.g. \u2014 as channel binding does \u2014 via the user authentication.\r\n> > \r\n> > \r\n> > of course noone ever authenticates ephemeral keys, that makes no sense. hence you have long-term keys also these are essential in this setup, via x3dh. and those are(or should be) authenticated during registration. the reason for having ephemeral keys is to have each session being unique, and you could say bound to each other, at least for the sake of replayability and forward security.\r\n> \r\n> This does not in any way authenticate long- or short term keys used by the secure channel.\r\n\r\nto quote https://signal.org/docs/specifications/x3dh/#sending-the-initial-message\r\n> The following diagram shows the DH calculations between keys. Note that DH1 and DH2 provide mutual authentication, while DH3 and DH4 provide forward secrecy.\r\n\r\nwhere dh[12] are the long-term keys, and dh[34] the ephemeral keys.\r\n\r\n> This is _exactly_ what channel binding is about; authenticating the otherwise independently set up secure channel, usually by authenticating the keys used.\r\n\r\nopaque actually authenticates the used long-term keys during the 3dh ake. channel binding is not about that, earlier we established channel binding is about making sure the messages after the authentication are somehow bound to the authentication.\r\n\r\n> This does not in any way authenticate long- or short term keys used by the secure channel.\r\n\r\nlong-term keys are authenticated by the 3dh. and that's all that matters.\r\n\r\n> > > > [\u2026] but that means that the channel doesn't have to be encrypted, it's enough if the channel is authenticated, so that a mitm cannot change or inject extra messages. and this also means that channel binding only makes sense if there is some kind of security layer (be it auth, or non-malleable confidentiality) after the authentication is successful.\r\n> > > \r\n> > > \r\n> > > Yes, and?\r\n> > > Notably, this does not imply that this channel can not already exist beforehand.\r\n> > \r\n> > \r\n> > no but it implies that the channel up to the authentication can be an entirely different one from the one after the authentication.\r\n> \r\n> Yes, and?\r\n\r\ni dunno if you know but opaque it self does not need an secure (in your definition) channel at all. so you can easily start with plaintext doing opaque, and then switch to something \"secure\".\r\n\r\n> > > You do not need to channel bind to a security layer established using SASL. The authenticity of it is _already_ established due to the authentication it came from. Channel binding is a _better replacement_ for SASL security layers.\r\n> > well i can totally imagine a completely plaintext (no CIA whatsoever) connection that authenticates parties that authenticate each other via opaque. although i'm not sure what you mean with \"the authenticity of ?it? is _already_ established due to the authentication it comes from\" i can also totally imagine a TLS connection via a MITMbox that authenticates peers using opaque. and when you write \"channel binding is a better replacement[..]\" again i'm not sure i understand you, since if you do OPAQUE and use the shared secret that falls out of it to just do a simple xchacha/poly1305 using that you also have implicit channel binding, even if there is an active party in the middle.\r\n> \r\n> If you use SASL security layers the security layer is a product of the authentication exchange. As a very rough approximation a proper SASL authentication exchange establishing a security layer should behave somewhat similar to an AKE (authenticated key exchange). So, the \"authenticity of [the security layer] is _already_ established [because it is based on a modified AKE]\"\r\n\r\nyes. that makes sense.\r\n\r\n> And thus, yes exactly. If you would use the session key from an OPAQUE authentication to establish a security layer you do not need channel binding.\r\n\r\nexactly. what i'm saying, even if sloppily. excuses for that.\r\n\r\n> > > Using OPAQUE to set up an authenticated TLS channel is completely orthogonal to SASL channel binding and does not remove the need for it.\r\n> > \r\n> > no, not at all. tls is just another security layer (with a whole lot of design-by-committee and politics) that is completely interchangeable with any other \"sane\" security layer. and actually TLS makes a lot of sense since it is an established proto, that is mostly tolerated everywhere (even the GFW). and opaque+tls is combining the best of both worlds. and i believe that tls-opaque is the correct way to do a sasl security layer based on opaque.\r\n> \r\n> No, this is entirely orthogonal. Using OPAQUE to bootstrap TLS has the specific applicability of setting up a mutually authenticated encrypted channel using TLS, much like client certificates do.\r\n\r\nyes, so it goes beyond plain tls as used generally.\r\n\r\n> And similiar to client certificates you would then use SASL `EXTERNAL` as the appropiate SASL mechanism.\r\n\r\naha! i think this is the misunderstanding, what i mean, that tls is only established after opaque, as the sl, not before, as it is not needed for opaque.\r\n\r\n> To drill it down, SASL security layers are a _very specific_ concept. They are very much not \"just use a secure channel like TLS\". So no, TLS-OPAQUE is not combining the best of both worlds, it is an entirely different thing.\r\n\r\ni'm not sure i follow, is this because we think of tls differently? you as something that sasl runs on and me as something were tls is the SL from opauqe?\r\nand the nice thing if we use the shared secret as the input for the session key of tls, then we can actually skip KE3 from opaque, as the encryption of the following packets will implicitly authenticate the client to the server. explicit user auth is only needed with opaque if the shared secret is not used for further encrypted communication.\r\n\r\n> I will give you half a point though. Using the TLS state machine is probably the best way of doing a SASL security layer. But you wouldn't use TLS-OPAQUE, because that doesn't give you what you need for SASL. Instead you'd do SASL OPAQUE and then use TLS-PSK with the session key.\r\n\r\nyou are closer to the correct way of doing this than i was in my sloppy way. tls-psk is almost what you want, but better, since psk is a static pre-shared key (as psk implies) it indeed needs roundtrips to set up the tls session, but from opaque a unique shared key already falls out, so you can skip a few steps i hope. but my tls proto understanding at this late stage of tls is limited, so it might be naive.\r\n\r\n> But at that point, **just use TLS**. The most you can save here is a single roundtrip for STARTTLS. And if you must reduce round-trips, just use TLS-OPAQUE and SASL EXTERNAL.\r\n\r\ni'm not sure i follow the last thought of you there? doesn't it mean that if you use sals external you already have setup tls and executed all the necessary roundtrips for it and there is no \"saving steps\" whereas if you skip those steps and present the shared key from opaque to be the \"session-key\" of tls then you indeed skip a few roundtrips?\r\n\r\n> > ([\u2026] or just plain naked xchacha20/poly1305)\r\n> \r\n> And that is a stupid idea. I hope you do realize how much of the TLS state machine is required just to make this specific AEAD safe to use.\r\n\r\nnope. please tell me. again, my context is, that opaque runs over unsecured channel and then switches to the secured channel using xchacha20/poly1305. not the other way around, having an \"encrypted\" or secure channel over which you run opaque.\r\n\r\n\r\nanyway i was thinking of your two goals:\r\n\r\n1/ channel binding to an existing tls session over which you run sasl (using perhaps opaque)\r\n2/ KSF configuration\r\n\r\ni don't think the original IRTF CFRG opaque spec needs any changes, both of these goals i think are simply achievable.\r\n\r\n1/ you want channel binding, so opaque itself authenticates the peers,\r\nwhich is ok, but you also want to authenticate the channel. so you\r\njust do an extra hmac with the shared secret over the channel\r\nparameters on the server before returning KE2, and the client can\r\nverify this hmac by recalculating the value itself. note this only\r\nbinds the channel for the client, if you also want to bind this for\r\nthe server we need to send back a similar but different hmac to the\r\nserver together with KE3. you don't modify the OPAQUE base spec at\r\nall, and you get what you want.\r\n\r\ni mean OPAQUE is a base primitive upon which a lot of other protos\r\nwill be (hopefully) built we can try to accomodate all of them and\r\nbloat opaque up, or we can actually build upon it, extending it like\r\nthe above. granted, you have 2 (or 4) more hmac calculations per\r\nconnection. on the client this makes absolutely no performance\r\ndifference, and considering the cost of doing all the elliptic curve\r\nstuff on the server one or two extra hmacs don't mean much of a\r\ndifference either.\r\n\r\n2/ you want to negotiate/specify somehow the KSF configuration. but i\r\nsay this is not necessary! because the server (in the IRTF CFRG\r\nspecified version) does not now or care about the clients KSF\r\nconfig. hell everything would work totally fine, if all clients would\r\nuse different KSF configs with the same server.\r\n\r\nthere is an exception to this, if the server implements the one-step\r\nnon-private password registration function that is specified in the\r\noriginal opaque paper, since then the server does it all, also the\r\ninitial KSF when registering. But the IRTF CFRG does specify only the\r\n4 step privacy respecting registration, where the client does the\r\nKSF. However and this sucks, SASL (afaik) doesn't support this, at\r\nleast with cyrus-sasl the admin uses saslpasswd2 on the server to\r\ncreate a new user. and this sucks a lot, since with opaque it is\r\nreally awesome that the password doesn't have to be ever exposed to\r\nthe server.\r\n\r\nso if the registration of users can be somehow solved to actually use\r\nthe 4 step privacy-protective registration procedure, then clients can\r\nchoose whatever they want for KSF. with one caveat though, in this\r\ncase the client needs to remember the KSF configuration, and another\r\ncool thing about opaque would be broken then, the fact that the client\r\ndoes not have to store or maintain any kind of state or\r\nconfiguration. which i guess is a bit of cheating, since the client\r\nneeds to know the server to which to initiate the opaque dance with,\r\nand if we store a server name, i guess it's also ok to store the ksf\r\nconfig next to it on clients.\r\n",
          "createdAt": "2022-10-05T16:35:05Z",
          "updatedAt": "2022-10-05T16:37:07Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "> to quote https://signal.org/docs/specifications/x3dh/#sending-the-initial-message\r\n> \r\n> > The following diagram shows the DH calculations between keys. Note that DH1 and DH2 provide mutual authentication, while DH3 and DH4 provide forward secrecy.\r\n> \r\n> where dh[12] are the long-term keys, and dh[34] the ephemeral keys.\r\n\r\nI know how X3DH works. None of that matters. See below.\r\n\r\n> opaque actually authenticates the used long-term keys during the 3dh ake. channel binding is not about that, earlier we established channel binding is about making sure the messages after the authentication are somehow bound to the authentication.\r\n\r\nNo, quoting RFC 5056: \r\n> Channel binding: the process of establishing that no man-in-the-middle exists between two end-points that have been authenticated at one network layer but are using a secure channel at a lower network layer. This term is used as a noun.\r\n\r\nChannel Binding does give you this latter assure you are talking about. But not every way of getting this assurance is called \"Channel Binding\" in the context of SASL.\r\n\r\n> > This does not in any way authenticate long- or short term keys used by the secure channel.\r\n> \r\n> long-term keys are authenticated by the 3dh. and that's all that matters.\r\n\r\nNo they aren't. And the fact that they aren't *is* what matters.\r\n\r\nSo, I think I know what the misunderstanding is. Channel Binding is used in the specific case where you have an already-established secure channel, and *after* establishing this secure channel perform some sort of authentication that validates this secure channel. This is not debatable, this is the definition of the term Channel Binding in the context of SASL. If you do not have this case, you can not have Channel Binding.\r\n\r\nNotably, to drill this down again, if you use SASL to establish a secure channel you can not use Channel Binding to bind to that particular channel.\r\n\r\nIf you perform OPAQUE in the clear, you can not have channel binding.\r\n\r\n> > > > > [\u2026] but that means that the channel doesn't have to be encrypted, it's enough if the channel is authenticated, so that a mitm cannot change or inject extra messages. and this also means that channel binding only makes sense if there is some kind of security layer (be it auth, or non-malleable confidentiality) after the authentication is successful.\r\n> > > > \r\n> > > > \r\n> > > > Yes, and?\r\n> > > > Notably, this does not imply that this channel can not already exist beforehand.\r\n> > > \r\n> > > \r\n> > > no but it implies that the channel up to the authentication can be an entirely different one from the one after the authentication.\r\n> > \r\n> > \r\n> > Yes, and?\r\n> \r\n> i dunno if you know but opaque it self does not need an secure (in your definition) channel at all. so you can easily start with plaintext doing opaque, and then switch to something \"secure\".\r\n \r\nYes thank you I am well aware of that. But as stated above in that case you **can not** have Channel Binding. And this issue is about Channel Binding. \r\n\r\nWhat you are describing there is using SASL to establish a secure channel, i.e. the \"security layer\" part of SASL. Which is an entirely different thing and completely orthogonal to Channel Binding. And, most importantly, does not *remove* the need for Channel Binding in the specific case in which Channel Binding can be used.\r\n\r\n\r\n> > To drill it down, SASL security layers are a _very specific_ concept. They are very much not \"just use a secure channel like TLS\". So no, TLS-OPAQUE is not combining the best of both worlds, it is an entirely different thing.\r\n> \r\n> i'm not sure i follow, is this because we think of tls differently? you as something that sasl runs on and me as something were tls is the SL from opauqe? and the nice thing if we use the shared secret as the input for the session key of tls, then we can actually skip KE3 from opaque, as the encryption of the following packets will implicitly authenticate the client to the server. explicit user auth is only needed with opaque if the shared secret is not used for further encrypted communication.\r\n\r\nTwo things:\r\n1. no I'm not thinking about TLS differently. But TLS doesn't magically become the SL of a SASL OPAQUE mechanism, it needs to be specified that way too. And it doesn't help us in the case where we would want to use Channel Binding, see above.\r\n2. No we can not drop KE3. The AEAD in use in modern TLS are not key committing, the fact that we can decrypt packets is not enough for strong authentication.\r\n\r\n> > I will give you half a point though. Using the TLS state machine is probably the best way of doing a SASL security layer. But you wouldn't use TLS-OPAQUE, because that doesn't give you what you need for SASL. Instead you'd do SASL OPAQUE and then use TLS-PSK with the session key.\r\n> \r\n> you are closer to the correct way of doing this than i was in my sloppy way. tls-psk is almost what you want, but better, since psk is a static pre-shared key (as psk implies) it indeed needs roundtrips to set up the tls session, but from opaque a unique shared key already falls out, so you can skip a few steps i hope. but my tls proto understanding at this late stage of tls is limited, so it might be naive.\r\n\r\nIn this specific use case, as the session key is unique per authentication, you could use the TLS PSK_KE mode which almost directly derives the master secret from the provided PSK, without losing forward secrecy. Using Early Data it also allows you to immediately use the TLS context without having to wait for the answer from the server.\r\n\r\n> > But at that point, **just use TLS**. The most you can save here is a single roundtrip for STARTTLS. And if you must reduce round-trips, just use TLS-OPAQUE and SASL EXTERNAL.\r\n> \r\n> i'm not sure i follow the last thought of you there? doesn't it mean that if you use sals external you already have setup tls and executed all the necessary roundtrips for it and there is no \"saving steps\" whereas if you skip those steps and present the shared key from opaque to be the \"session-key\" of tls then you indeed skip a few roundtrips?\r\n\r\nLet's do an example. I'm doing IMAP by the book using STARTTLS. The first round-trip goes to IMAP EHLO, the second and third to STARTTLS handshakes, and the fourth for 'AUTH EXTERNAL'. I am now authenticated.\r\n\r\nNext example. I'm doing IMAP with SASL OPAQUE with a security layer established by that. The first round-trip again goes to IMAP EHLO, the second and third however go to 'AUTH OPAQUE'. I am now authenticated and have established a security layer.\r\n\r\nNow, last example. I'm doing IMAPS using TLS-OPAQUE. The first and second round-trip go towards TLS-OPAQUE. If I have a fancy IMAP implementation I am immediately authenticated with no further actions necessary. If not, I may need a third roundtrip for 'AUTH EXTERNAL'.\r\nHowever depending on how TLS-OPAQUE is done the server may also be able to already send the IMAP EHLO in the *first* round-trip using the (not yet verified) session key, in essence sending the IMAP EHLO directly after KE2 without waiting for the client answering with KE3. The client may also send its first IMAP commands directly after KE3 since it could decrypt the IMAP EHLO sent after KE2.\r\n\r\nNotably, *none* of this early data shenanigans of the last example is possible with a SASL security layer. If you need to keep round-trips to an absolute minimum, TLS-OPAQUE is the way to go.\r\n\r\n> > > ([\u2026] or just plain naked xchacha20/poly1305)\r\n> > \r\n> > \r\n> > And that is a stupid idea. I hope you do realize how much of the TLS state machine is required just to make this specific AEAD safe to use.\r\n> \r\n> nope. please tell me. again, my context is, that opaque runs over unsecured channel and then switches to the secured channel using xchacha20/poly1305. not the other way around, having an \"encrypted\" or secure channel over which you run opaque.\r\n\r\nRight, you probably know that XChaCha20/Poly1305 too has usage limits. They are designed to be high, but they do exist. TLS implementations rotate their traffic keys quite regularly. Yes, the usage limits of XChaCha20/Poly1305 are high enough that most prolonged usages are safe enough but the question of \"is it safe?\" quickly becomes one of \"what's your threat model\" and I do not want to write out a threat model in an *SASL* RFC.\r\n\r\n\r\n> anyway i was thinking of your two goals:\r\n> \r\n> 1/ channel binding to an existing tls session over which you run sasl (using perhaps opaque) 2/ KSF configuration\r\n> \r\n> i don't think the original IRTF CFRG opaque spec needs any changes, both of these goals i think are simply achievable.\r\n> \r\n> 1/ you want channel binding, so opaque itself authenticates the peers, which is ok, but you also want to authenticate the channel. so you just do an extra hmac with the shared secret over the channel parameters on the server before returning KE2, and the client can verify this hmac by recalculating the value itself. note this only binds the channel for the client, if you also want to bind this for the server we need to send back a similar but different hmac to the server together with KE3. you don't modify the OPAQUE base spec at all, and you get what you want.\r\n\r\nI could do that, yes. But I could also skip that extra HMAC and then also wouldn't be forced to violate [Section 6.2.4. of the OPAQUE spec](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#section-6.2.4) saying, and I quote, \"[The ServerFinish function] MUST NOT return the session_key value if the client authentication material is invalid\".\r\n\r\nSo no, if anything I could send it from client to server in the last message, i.e. next to KE3.\r\n\r\nBut again, I could also use the MAC that is *already there for this specific purpose*. Which, IMO, makes just slightly more sense.\r\n\r\n> i mean OPAQUE is a base primitive upon which a lot of other protos will be (hopefully) built we can try to accomodate all of them and bloat opaque up, or we can actually build upon it, extending it like the above. granted, you have 2 (or 4) more hmac calculations per connection. on the client this makes absolutely no performance difference, and considering the cost of doing all the elliptic curve stuff on the server one or two extra hmacs don't mean much of a difference either.\r\n\r\nThe change I am proposing does not bloat up OPAQUE in any way shape or form. It is merely improving the ability of OPAQUE to be extended for the things that want to use it. \r\n\r\n> 2/ you want to negotiate/specify somehow the KSF configuration. but i say this is not necessary! because the server (in the IRTF CFRG specified version) does not now or care about the clients KSF config. hell everything would work totally fine, if all clients would use different KSF configs with the same server.\r\n\r\nHow does my phone know the parameters that my computer has used to register? Every *user* can use their own KSF config on the same server. But not every *client*. Very, very far from it.\r\n\r\nAnd as I see it, there are only really two options for this. One of them is somewhat stupid, and the other one is sending *authenticated* KSF parameters to authenticating clients.",
          "createdAt": "2022-10-05T17:38:52Z",
          "updatedAt": "2022-10-05T17:38:52Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "snipping the what is channel binding part, which as a concept i misunderstood.\r\n\r\n> So, I think I know what the misunderstanding is. Channel Binding is used in the specific case where you have an already-established secure channel, and _after_ establishing this secure channel perform some sort of authentication that validates this secure channel. This is not debatable, this is the definition of the term Channel Binding in the context of SASL. If you do not have this case, you can not have Channel Binding.\r\n> \r\n> Notably, to drill this down again, if you use SASL to establish a secure channel you can not use Channel Binding to bind to that particular channel.\r\n> \r\n> If you perform OPAQUE in the clear, you can not have channel binding.\r\n\r\n\r\n>     1. no I'm not thinking about TLS differently. But TLS doesn't magically become the SL of a SASL OPAQUE mechanism, it needs to be specified that way too. And it doesn't help us in the case where we would want to use Channel Binding, see above.\r\n\r\nwell, we do think differently of the application of tls here. but it doesnt matter, yes if used as an SL it needs to be specified for doing so.\r\n\r\n>     2. No we can not drop KE3. The AEAD in use in modern TLS are not key committing, the fact that we can decrypt packets is not enough for strong authentication.\r\n\r\nyes we can. believe me, my implementation was the target of the awesome particioning oracle paper, and thus i understand the concept of key committing and the consequences of it. (note that the paper authors had to circumvent my defense in depth measures to mount their attack against my implementation, but they called it a memory safety bug.) so the thing is, since opaque used hmac for authenticating the \"envelope\" it is keycommitting, and if that hmac fails then opaque fails and no key is being used in poly1305 (which is the part that is non-key committing, not xchacha20). if the hmac succeeds, then it doesn't matter if poly1305 is key committting or not.\r\n\r\n\r\n> In this specific use case, as the session key is unique per authentication, you could use the TLS PSK_KE mode which almost directly derives the master secret from the provided PSK, without losing forward secrecy. Using Early Data it also allows you to immediately use the TLS context without having to wait for the answer from the server.\r\n\r\nthat sounds quite nice, no?\r\n\r\n> Let's do an example. I'm doing IMAP by the book using STARTTLS. The first round-trip goes to IMAP EHLO, the second and third to STARTTLS handshakes, and the fourth for 'AUTH EXTERNAL'. I am now authenticated.\r\n> Next example. I'm doing IMAP with SASL OPAQUE with a security layer established by that. The first round-trip again goes to IMAP EHLO, the second and third however go to 'AUTH OPAQUE'. I am now authenticated and have established a security layer.\r\n> Now, last example. I'm doing IMAPS using TLS-OPAQUE. The first and second round-trip go towards TLS-OPAQUE. If I have a fancy IMAP implementation I am immediately authenticated with no further actions necessary. If not, I may need a third roundtrip for 'AUTH EXTERNAL'. However depending on how TLS-OPAQUE is done the server may also be able to already send the IMAP EHLO in the _first_ round-trip using the (not yet verified) session key, in essence sending the IMAP EHLO directly after KE2 without waiting for the client answering with KE3. The client may also send its first IMAP commands directly after KE3 since it could decrypt the IMAP EHLO sent after KE2.\r\n\r\nit is totally ok for the server to send data already together after KE2, but the client can only process that data if KE2 authenticates correctly.\r\n\r\n> Notably, _none_ of this early data shenanigans of the last example is possible with a SASL security layer. If you need to keep round-trips to an absolute minimum, TLS-OPAQUE is the way to go.\r\n\r\nyes. and it also eliminates the need for any sasl, which is also cool.\r\n\r\n> Right, you probably know that XChaCha20/Poly1305 too has usage limits. They are designed to be high, but they do exist. TLS implementations rotate their traffic keys quite regularly. Yes, the usage limits of XChaCha20/Poly1305 are high enough that most prolonged usages are safe enough but the question of \"is it safe?\" quickly becomes one of \"what's your threat model\" and I do not want to write out a threat model in an _SASL_ RFC.\r\n\r\nxchacha20 has a 196 bit nonce, which was chosen to be so large to make it practically impossible for it to ever loop around. and thus the \"is it safe?\" question is a very-very theoretical one.\r\n\r\n> > anyway i was thinking of your two goals:\r\n> > 1/ channel binding to an existing tls session over which you run sasl (using perhaps opaque) 2/ KSF configuration\r\n> > i don't think the original IRTF CFRG opaque spec needs any changes, both of these goals i think are simply achievable.\r\n> > 1/ you want channel binding, so opaque itself authenticates the peers, which is ok, but you also want to authenticate the channel. so you just do an extra hmac with the shared secret over the channel parameters on the server before returning KE2, and the client can verify this hmac by recalculating the value itself. note this only binds the channel for the client, if you also want to bind this for the server we need to send back a similar but different hmac to the server together with KE3. you don't modify the OPAQUE base spec at all, and you get what you want.\r\n> \r\n> I could do that, yes. But I could also skip that extra HMAC and then also wouldn't be forced to violate [Section 6.2.4. of the OPAQUE spec](https://cfrg.github.io/draft-irtf-cfrg-opaque/draft-irtf-cfrg-opaque.html#section-6.2.4) saying, and I quote, \"[The ServerFinish function] MUST NOT return the session_key value if the client authentication material is invalid\".\r\n\r\nhmm. that is curious, i'm very intimate with opaque, and the original paper does not have this limitation. in fact also during drafting of the opaque spec we had lots of discussions of sending extra protocol data already from the server with ke2, with an extra key, but then we threw away that extra key, saying that extra data can also be sent just with the session key itself. hmmm. gotta dig that up, why this requirement is now there. \r\n\r\n> So no, if anything I could send it from client to server in the last message, i.e. next to KE3.\r\n\r\nyes, if it turns out that requirement is indeed necessary then yes.\r\n\r\n> But again, I could also use the MAC that is _already there for this specific purpose_. Which, IMO, makes just slightly more sense.\r\n\r\nif it would be there for this specific purpose it would allow extra parameters, wouldn't it?\r\n\r\n> > i mean OPAQUE is a base primitive upon which a lot of other protos will be (hopefully) built we can try to accomodate all of them and bloat opaque up, or we can actually build upon it, extending it like the above. granted, you have 2 (or 4) more hmac calculations per connection. on the client this makes absolutely no performance difference, and considering the cost of doing all the elliptic curve stuff on the server one or two extra hmacs don't mean much of a difference either.\r\n> \r\n> The change I am proposing does not bloat up OPAQUE in any way shape or form. It is merely improving the ability of OPAQUE to be extended for the things that want to use it.\r\n\r\ni didnt mean you bloat it up, i meant that accomodating all possible uses of opaque and incorporating all their special needs would do so. it's quite a difference, don't take this as any offense please.\r\n\r\n> > 2/ you want to negotiate/specify somehow the KSF configuration. but i say this is not necessary! because the server (in the IRTF CFRG specified version) does not now or care about the clients KSF config. hell everything would work totally fine, if all clients would use different KSF configs with the same server.\r\n> \r\n> How does my phone know the parameters that my computer has used to register?\r\n\r\ni guess by presenting a drop down menu with a reasonable default, and a bunch of hardcoded extra configs like yolo and paranoia? and storing that info if it turns out correct. this is something that should be solved by a UI i think, and most people should just stick with the default anyway, so i guess config file/cli parameter is enough for the 1%. and it's not like you can easily change the KSF config, you need to reregister if you wanna change it, that is also kind of a pain.\r\n\r\n> Every _user_ can use their own KSF config on the same server. But not every _client_. Very, very far from it.\r\n\r\ntrue, i meant to write users, not clients.\r\n\r\n> And as I see it, there are only really two options for this. One of them is somewhat stupid, and the other one is sending _authenticated_ KSF parameters to authenticating clients.\r\n\r\nok, and what is wrong with: ksf config simply signed by the servers longterm key and sent along with ke2?\r\n",
          "createdAt": "2022-10-05T19:48:50Z",
          "updatedAt": "2022-10-05T19:48:50Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "> ok, and what is wrong with: ksf config simply signed by the servers longterm key and sent along with ke2?\r\n\r\nand the client can just cache the value if it turns out the config sent is correct.",
          "createdAt": "2022-10-05T19:52:34Z",
          "updatedAt": "2022-10-05T19:52:43Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "hmmm, maybe not, not sure if the longterm server key is already available to the client before opening the envelope. the spec has gone quite far from the original paper, and it's kinda confusing with all the changes and back-and-forth over the last years that were put into the draft.",
          "createdAt": "2022-10-05T19:54:49Z",
          "updatedAt": "2022-10-05T19:54:49Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "At this point I have nothing to add to this issue. If there are more comments on the original topic feel free to add them.",
          "createdAt": "2022-10-06T18:02:18Z",
          "updatedAt": "2022-10-06T18:02:18Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOH68eks5TQC6x",
      "title": "Integrity protecting the authentication exchange",
      "url": "https://github.com/dequbed/draft-reitzenstein-auth-opaque/issues/2",
      "state": "CLOSED",
      "author": "dequbed",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Link to the upstream issue required for this so I don't lose it: https://github.com/cfrg/draft-irtf-cfrg-opaque/issues/375",
      "createdAt": "2022-10-04T18:59:47Z",
      "updatedAt": "2022-10-06T17:36:48Z",
      "closedAt": "2022-10-06T17:36:48Z",
      "comments": [
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "The current solution has become to use the parts of the exchange requiring integrity protection in the client- and server_identity values.\r\n\r\nThis does however leaves the issue that the KSF parameters can neither directly nor indirectly be validated until after they have been used. This is a problem that may not be easily solveable given the current 3DH architecture.",
          "createdAt": "2022-10-06T17:36:38Z",
          "updatedAt": "2022-10-06T17:36:38Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOH68eks5blniX",
      "title": "registration issue",
      "url": "https://github.com/dequbed/draft-reitzenstein-auth-opaque/issues/3",
      "state": "OPEN",
      "author": "stef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The OPAQUE RFC only specifies the 4 step password-privacy-protecting registration procedure, which does not apply to how SASL (and i assume also gss-api) creates new/registers users. With SASL new users are usually added on the server by using a tool like saslpasswd2 which creates the accounts for all SASL supported mechanisms, and thus the users password is exposed to the server. On one hand this violates one of OPAQUEs security guarantees, never exposing the password to the server, but on the other hand it enables the server to enforce password quality rules.",
      "createdAt": "2023-01-17T15:33:25Z",
      "updatedAt": "2023-01-17T20:09:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "The SASL protocol does not concern itself with matter of registration and password changes. It's also not a new topic, SCRAM has the same issue. Registration/Password Changes has always been responsibility of the higher level protocol or server software.\r\n\r\nI would absolutely love the ability of safe registration in SASL, but sadly we don't have that at the moment. SASL2 as is proposed for use in XMPP has some ideas for solutions regarding that.\r\n\r\nIf something like SASL2 becomes a thing I'll glady add features regarding that to this specification or a new draft.",
          "createdAt": "2023-01-17T18:08:09Z",
          "updatedAt": "2023-01-17T18:08:09Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "i think this deserves a mention in the security considerations at least",
          "createdAt": "2023-01-17T18:31:18Z",
          "updatedAt": "2023-01-17T18:31:18Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "> i think this deserves a mention in the security considerations at least\r\n\r\nThat's a fair point. I will add it to the security considerations.\r\n\r\nAdditionally after some further discussion with Thilo Molitor it's sensible to add a specified encoding for registration messages because he does have a XEP in the works that could make sensible use of this.",
          "createdAt": "2023-01-17T18:54:03Z",
          "updatedAt": "2023-01-17T18:54:03Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "yay. \r\n\r\ni was also thinking, that OPAQUE as a protocol specifies both, registration and ake. if sasl only does the ake, is it still opaque? maybe it would be better to refer to a partial opaque protocol then.",
          "createdAt": "2023-01-17T19:28:38Z",
          "updatedAt": "2023-01-17T19:28:38Z"
        },
        {
          "author": "dequbed",
          "authorAssociation": "OWNER",
          "body": "> i was also thinking, that OPAQUE as a protocol specifies both, registration and ake. if sasl only does the ake, is it still opaque? maybe it would be better to refer to a partial opaque protocol then.\r\n\r\nThe OPAQUE draft calls OPAQUE \"a secure asymmetric password-authenticated key exchange [protocol]\". My draft is titled \"A [\u2026] Mechanism using the asymmetric password-authenticated key agreement OPAQUE\" so no, the name is very much appropiate as the core feature of OPAQUE is the aPAKE, which is also the part that the mechanism is using.",
          "createdAt": "2023-01-17T19:41:42Z",
          "updatedAt": "2023-01-17T19:41:42Z"
        },
        {
          "author": "stef",
          "authorAssociation": "NONE",
          "body": "the setup phase very much part of the protocol. but yeah, your title is more nuanced, but only for people reading very closely.",
          "createdAt": "2023-01-17T20:09:28Z",
          "updatedAt": "2023-01-17T20:09:28Z"
        }
      ]
    }
  ],
  "pulls": []
}